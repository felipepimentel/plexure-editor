# Swagger Editor UI Generator

## Technology Guidelines

### Development

1. Use **Vite** for web servers and project scaffolding.
2. Prefer **Node.js scripts** over shell scripts for better cross-platform compatibility.
3. Utilize JavaScript-based libraries and databases (e.g., SQLite, `@supabase/supabase-js`) only when necessary and justified.
4. Validate all structural changes against the predefined structure file (`STRUCTURE.md`) before generating or modifying code. Use automated scripts or CI/CD pipelines to ensure that the project structure complies with the defined standards, minimizing manual intervention and reducing errors.
5. Do not create or use unnecessary dependencies, libraries, or files. Verify their necessity before including them in the project.
6. All code, instructions, and documentation generated must be in **English**, ensuring consistency and readability across the project.

### UI and Design

1. Use **React + TypeScript** with **Tailwind CSS** for styling.
2. Incorporate `lucide-react` for icons and graphical elements only when needed.
3. Ensure designs are:
   - **Responsive**
   - **Accessible**, meeting **WCAG standards**
   - **Mobile-first**
4. Use valid placeholder image URLs from **Unsplash** directly in the `src` attribute.
5. Reuse existing styles and components to maintain consistency and avoid duplication. During development, first check the `src/components/` directory for existing solutions that meet your requirements. If creating a new component is unavoidable, ensure it is modular, adheres to existing design patterns, and follows the established naming conventions. For example, instead of creating duplicate button styles, extend the existing `Button` component by passing additional props to handle unique scenarios.

### Project Structure

#### Directory Structure [P0]

```
src/
├── components/          # Reusable components
│   ├── ui/              # Basic UI components
│   ├── forms/           # Form-specific components
│   └── navigation/      # Navigation components
├── features/            # Application-specific features
│   ├── feature_name/    # Feature-specific directories
│   │   ├── hooks/       # Feature hooks
│   │   └── utils/       # Feature utilities
├── views/               # Application pages
│   ├── PageName/        # Page-specific directories
│   │   ├── index.tsx    # Page composition
│   │   └── sections/    # Page sections
└── utils/               # General-purpose utilities
```

#### Guidelines

1. **Components (********`src/components/`********)**

   - Reusable and independent.
   - Grouped by domain (`ui`, `forms`, `navigation`).
   - Flat structure, no nested `components` subfolders.

2. **Features (********`src/features/`********)**

   - Encapsulate specific application logic.
   - May include `hooks` and `utils` specific to the feature.

3. **Views (********`src/views/`********)**

   - Organize by pages.
   - Use `sections/` for complex page layouts.

#### Principles [P0]

1. **Simplicity**

   - Prefer flat structures.
   - Avoid deep nesting.
   - Use clear, descriptive names.

2. **Organization**

   - Components by domain.
   - Features by functionality.
   - Views by page.

3. **Reusability**

   - Build reusable components.
   - Encapsulate logic in features.
   - Compose views using existing elements.

#### Anti-Patterns [P0]

❌ **Avoid**

- Deeply nested directories.
- Unnecessary subfolders.
- Mixing unrelated responsibilities.

✅ **Prefer**

- Clear separation of concerns.
- Descriptive and specific naming.
- Maintaining consistency with the `project-structure.yaml`.

### Response Standards

#### Format

1. Provide responses in **valid markdown**.
2. Avoid HTML unless necessary for specific styling or layout (e.g., `<div>`, `<code>`).
3. All content, including comments, should be written in **English**.

#### Quality

1. Ensure code is **production-ready**, polished, and professional.
2. Deliver solutions that are functional, unique, and visually appealing.
3. Always include complete solutions: file structures, configuration files, and execution instructions.

#### Artifacts

1. Each response must include:
   - All necessary files (e.g., JSX, CSS, configuration).
   - A step-by-step guide to install and execute the solution.
   - Dependencies managed via `package.json`.

### Best Practices

#### Code

1. Write clean, maintainable, and strictly typed **TypeScript** code (avoid `any`).
2. Use `React.FC` for functional components with well-defined props.
3. Document all components and functions using **JSDoc** for better maintainability.
4. Ensure code adheres to the **project structure file** guidelines.
5. Reuse existing components and utilities. Do not create new components, utilities, or logic without verifying the absence of an existing solution.

#### Performance

1. Use memoization techniques (`React.memo`, `useMemo`, `useCallback`) to reduce unnecessary re-renders. Memoization is particularly beneficial in scenarios where components depend on complex computations, reusable callback functions, or static props in large lists or frequent re-rendering contexts, such as rendering table rows or dynamically updating forms.
2. Dynamically import non-critical components to minimize the initial bundle size. For example, use React's `lazy` and `Suspense`:

```tsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <LazyComponent />
  </Suspense>
);

export default App;
```

3. Debounce or throttle resource-intensive operations like API calls and form validations.

### Next Steps / Improvements

#### Continuous Improvement

1. After completing a feature or implementation, provide recommendations for future improvements or extensions:
   - Adding new components, pages, or features that enhance user experience.
   - Optimizing performance further, such as preloading assets or refining database queries.
   - Enhancing documentation for developers and end-users.

#### Maintainability and Evolution

1. Refactor repetitive code into reusable utilities or components.
2. Adopt emerging technologies that align with the project (e.g., new React features, AI-driven enhancements).
3. Validate and document all significant architectural changes.

#### Scalability

1. Recommendations for handling larger datasets or traffic spikes.
2. Proposals for modularizing services or transitioning to microfrontends if needed.
3. Use the `project-structure.yaml` file as a blueprint for scaling architecture and ensuring consistency in multi-team environments.

## Expected Output

By following this prompt, all generated solutions will:

1. Adhere to modern web development standards and best practices.
2. Be production-ready, visually appealing, and fully functional.
3. Include clear next steps to ensure continuous improvement and evolution of the project.
4. Avoid unnecessary libraries, files, and dependencies to keep the project lean and maintainable.
5. Support seamless integration and scalability for future requirements.

